import pandas as pdfrom sklearn.feature_extraction.text import TfidfVectorizerimport nltkimport pre_processing as PPfrom nltk.corpus import stopwordsstopwords.words('english')def ComputeTFIDF(documentA, documentB):    new_list = documentA[:]    wordB = PP.process(documentB)    word_auxB = PP.stemmingWord(wordB)    new_list.append(word_auxB)    vectorizer = TfidfVectorizer()    vectors = vectorizer.fit_transform(new_list)    feature_names = vectorizer.get_feature_names()    dense = vectors.todense()    denselist = dense.tolist()    df = pd.DataFrame(denselist, columns=feature_names)    max_val = {}    for i in range(df.shape[0]):        max_val[i] = 0.0    bagOfWordsB = PP.process(documentB)    bagOfWordsB = PP.StemmingWord(bagOfWordsB)    for x in range(df.shape[0]-1):        c = 0        for word in bagOfWordsB:            if word in df.columns:                c += 1                max_val[x] += df.at[x,word]        max_val[x] = max_val[x]/c    max_val_aux = 0.0    chave = -1    for key in max_val:        if (max_val_aux <= max_val[key]):            max_val_aux = max_val[key]            chave = key    result = [max_val_aux,-1,str(chave + 1)]    return resultdef editDistance(documents, goal):    #preprocess goal:    new_goal = PP.process(goal)    goal = ' '.join([str(elem) for elem in new_goal])    min = [-1,0,0]    for document in documents:        #create string of the document        e = 0        best_question = [-1,0]        for e in range(len(document)-1):            phrase = ' '.join([str(elem) for elem in document[e]])            diff = nltk.edit_distance(phrase, goal)            if (diff < best_question[0] or best_question[0] == -1):                best_question[0] = diff                best_question[1] = phrase                #print(best_question)        number = document[e+1][0]        #print(number)        if (best_question[0] < min[0] or min[0]==-1):            min[0] = best_question[0]            min[1] = best_question[1]            min[2] = number    #print("GOAL:\n", goal)    return mindef jaccard (documents, goal):    #preprocess goal:    new_goal = PP.process(goal)    goal = set(new_goal)    min = [-1,0,0]    for document in documents:        #create string of the document        e = 0        best_question = [-1,0]        for e in range(len(document)-1):            phrase = set(document[e])            diff = nltk.jaccard_distance(phrase,goal)            if (diff < best_question[0] or best_question[0] == -1):                best_question[0] = diff                best_question[1] = phrase                #print(best_question)        number = document[e+1][0]        #print(number)        if (best_question[0] < min[0] or min[0]==-1):            min[0] = best_question[0]            min[1] = best_question[1]            min[2] = number    #print("GOAL:\n", goal)    return min